<div class="chat-container mt-5">
  <h1 class="text-center mb-4">Rescue AI Chat</h1>

  <!-- --- Error alert if AI failed --- -->
  <% if @status == "error" %>
    <div class="alert alert-danger text-center fw-bold">
      ‚ö†Ô∏è AI error:
      <%= @error_message.presence || "An unexpected problem occurred. Please try again later." %>
    </div>
  <% end %>

  <!-- --- Chat window area --- -->
  <div class="chat-window shadow-sm bg-secondary p-4 border border-4 border-dark">

    <% if @intake.present? && !@mock%>
      <!-- Real AI mode: every chat bubble comes from the database so the poll controller can refresh them -->
      <div id="chat_messages">
        <% (@chat_messages || []).each do |message| %>
          <%= render partial: "intakes/message", locals: { message: message } %>
        <% end %>
      </div>

    <% elsif @mock %>
      <!-- --- MOCK MODE (Frontend only, no database) ---
           When mock mode is active, there is no Intake record in the database.
           Instead, fake data is generated in the controller and rendered directly here.
           This is purely for demo/testing purposes, so refreshing the page will lose the data.
           -->
      <div id="chat_messages">

        <!-- --- Mock user message bubble ---
            This represents what a user would type into the chat.
            -->
        <div class="chat-bubble user-message mb-3">
          I found an injured pigeon near the park. It can‚Äôt fly and looks weak. What should I do?
        </div>

        <!-- --- Mock assistant (AI) reply bubble ---
            This simulates the AI‚Äôs response without calling any backend.
            -->
        <%= render partial: "intakes/message",
        locals: { message: OpenStruct.new(id: "mock-ai",
                                          role: "assistant",
                                          content: "Try to keep the pigeon calm and warm in a ventilated box. Offer a little water, but don‚Äôt feed it yet. Avoid touching the wings ‚Äî and if it‚Äôs bleeding or can‚Äôt move, contact a local wildlife rescue center for proper care."),
        animate: true } %>

      </div>

    <% else %>
      <!-- Fallback if no AI response -->
      <div class="alert alert-warning text-center fw-bold">
        ‚ö†Ô∏è No AI response available.
      </div>
    <% end %>
  </div>

  <!-- --- Chat input area ---
       The user can submit a new message here.
       When mock mode is enabled, the request will generate fake data in the controller
       and render this same view without any database interaction.
       -->
  <% if @intake.present? && @intake.persisted? && !@mock %>
    <div class="chat-input-area mt-3">
      <%= form_with url: message_intake_path(@intake), method: :post, local: true, data: { turbo: false }, class: "d-flex" do |f| %>
        <%= f.text_field :content, name: "message[content]", placeholder: "Type your message...", class: "form-control me-2 chat-input" %>
        <%= f.submit "Send", class: "btn btn-dark" %>
      <% end %>
    </div>
  <% elsif @mock %>
    <div class="chat-input-area mt-3">
      <div class="alert alert-info text-center">
        üìù Mock mode - Input disabled. Refresh to start a real conversation.
      </div>
    </div>
  <% end %>

  <!-- --- Navigation area --- -->
  <div class="text-center mt-4">
    <%= link_to "Show vets nearby", root_path, class: "btn btn-outline-dark btn-lg" %>
  </div>
</div>
<script>
document.addEventListener("DOMContentLoaded", () => {
  // Find all AI message bubbles that should animate
  const aiBubbles = document.querySelectorAll(".ai-message[data-message]");

  aiBubbles.forEach(bubble => {
    const text = bubble.dataset.message || "";
    const aiText = bubble.querySelector(".ai-text");
    const thinking = bubble.querySelector("[data-thinking]");

    // Only run animation if animate==true in the render call
    if (!aiText || !text.length) return;

    // Brief thinking delay, then fade out the loader and type text
    setTimeout(() => {
      if (thinking) {
        thinking.style.transition = "opacity .35s ease";
        thinking.style.opacity = "0";
        setTimeout(() => thinking.remove(), 350);
      }

      let i = 0;
      const interval = setInterval(() => {
        aiText.textContent += text.charAt(i);
        i++;
        if (i >= text.length) clearInterval(interval);
      }, 15);
    }, 1500); // 1.5s "thinking" delay
  });
});
</script>
