<!-- Prevent flash by hiding element before render if animation is needed -->
<script>
  if (sessionStorage.getItem('chatShouldSlideIn') === 'true') {
    document.write('<style>#chat-page-container { opacity: 0; }</style>');
  }
</script>

<% should_slide = session.delete(:slide_transition) || false %>
<div class="chat-page" data-controller="slide-transition chat-scroll" data-slide-transition-slide-in-value="<%= should_slide %>" id="chat-page-container">

  <!-- Chat Header (Fixed) -->
  <div class="chat-page-header">
    <%= link_to new_intake_path, class: "header-button-dark" do %>
    <span class="cta-arrow">←</span>
       Back
    <% end %>
    <%
      # Highlight vet button for medium/high danger levels
      danger_level = @result&.dig("danger")&.downcase
      vet_button_class = ["header-button-dark"]
      # Accept: medium, high, urgent, emergency
      urgent_levels = %w[medium high urgent emergency]
      vet_button_class << "vet-button-urgent" if urgent_levels.include?(danger_level)
    %>
    <%= link_to vets_path(intake_id: @intake&.id), class: vet_button_class.join(" ") do %>
      vets nearby
      <span class="cta-arrow">→</span>
    <% end %>
  </div>

  <!-- Error alert if AI failed -->
  <% if @status == "error" %>
    <div class="alert alert-danger mx-3 mt-3 text-center">
      ⚠️ AI error: <%= @error_message.presence || "An unexpected problem occurred. Please try again later." %>
    </div>
  <% end %>

  <!-- Scrollable Messages Area -->
  <div class="chat-messages-container" data-chat-scroll-target="container">

    <% if @intake.present? && !@mock%>
      <!-- Real AI mode: every chat bubble comes from the database so the poll controller can refresh them -->
      <div id="chat_messages">
        <% (@chat_messages || []).each do |message| %>
          <%= render partial: "intakes/message", locals: { message: message } %>
        <% end %>
      </div>

    <% elsif @mock %>
      <!-- --- MOCK MODE (Frontend only, no database) ---
           When mock mode is active, there is no Intake record in the database.
           Instead, fake data is generated in the controller and rendered directly here.
           This is purely for demo/testing purposes, so refreshing the page will lose the data.
           -->
      <%= render partial: "intakes/mock_message" %>

    <% else %>
      <!-- Fallback if no AI response -->
      <div class="alert alert-warning text-center fw-bold">
        ⚠️ No AI response available.
      </div>
    <% end %>
  </div>

  <!-- Fixed Input Area at Bottom -->
    <% if @intake.present? && @intake.persisted? && !@mock %>
      <div class="chat-input-fixed">
        <%= form_with url: message_intake_path(@intake), method: :post, local: true, data: { controller: "chat-form", action: "submit->chat-form#submitMessage" }, class: "chat-input-form" do |f| %>
          <div class="input-wrapper">
            <%= f.text_field :content, name: "message[content]", placeholder: "Type your message...", class: "chat-input", autocomplete: "off", data: { chat_form_target: "input" } %>
            <%= f.submit "Send", class: "chat-send-btn", data: { chat_form_target: "submit" } %>
          </div>
        <% end %>
      </div>
    <% end %>

</div>
